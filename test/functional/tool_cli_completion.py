#!/usr/bin/env python3
# Copyright (c) 2020 The Bitcoin Core developers
# Distributed under the MIT software license, see the accompanying
# file COPYING or http://www.opensource.org/licenses/mit-license.php.
"""Tests the bitcoin-cli bash autocompletion file.

This checks that the bitcoin-cli bash autocompletion file in the
contrib/ folder match the RPC calls available.
"""

from os import path
from re import compile, MULTILINE, DOTALL
from collections import defaultdict

from test_framework.test_framework import BitcoinTestFramework
from test_framework.util import assert_equal


# bash cli completion file header
COMPLETION_HEADER = """# Dynamic bash programmable completion for bitcoin-cli(1)
#     DO NOT EDIT THIS FILE BY HAND -- THIS WILL FAIL THE FUNCTIONAL TEST tool_cli_completion
# This file is auto-generated by the functional test tool_cli_completion.
# If you want to modify this file, modify test/functional/tool_cli_completion.py and re-autogenerate
# this file via the --overwrite test flag.

"""

# option types which are limited to certain values
TYPED_OPTIONS = [
        ["estimate_mode", {"UNSET", "ECONOMICAL", "CONSERVATIVE"}],
        ["sighashtype", {"ALL", "NONE", "SINGLE", "ALL|ANYONECANPAY",
                         "NONE|ANYONECANPAY", "SINGLE|ANYONECANPAY"}]
]

# regexp to extract arguments from the help of a single command
ARG_REGEXP = compile(r'.*Arguments\s*:\s*\n*(.*)\n*\s*Result', MULTILINE | DOTALL)


class PossibleArgs():
    """ Helper class to store options associated to a command. """
    def __init__(self, command):
        self.command = command
        self.arguments = {}

    def set_args(self, position, values):
        """ Set the position-th positional argument as having values as possible values. """
        if position in self.arguments:
            raise AssertionError(("{} positional parameter already "
                                 "defined for command {}").format(position, self.command))

        self.arguments[position] = values
        return self

    def set_bool_args(self, position):
        return self.set_args(position, {"true", "false"})

    def set_file_args(self, position):
        # We consider an empty string as a file value for the sake of simplicity (don't
        # have to create an extra level of indirection).
        return self.set_args(position, {""})

    def set_unknwon_args(self, position):
        return self.set_args(position, {})

    def has_option(self, position):
        return position in self.arguments and len(self.arguments[position]) > 0

    def get_num_args(self):
        """ Return the max number of positional argument the option accepts. """
        pos = list(self.arguments.keys())
        if len(pos) == 0:
            return 0

        return max(pos)

    def generate_autocomplete(self, pos):
        """ Generate the autocomplete file line relevent to the given position pos. """
        if len(self.arguments[pos]) == 0:
            raise AssertionError("generating undefined arg id {} ({})".format(pos, self.arguments))

        # handle special file case
        if len(self.arguments[pos]) == 1 and len(next(iter(self.arguments[pos]))) == 0:
            return "_filedir"

        # a set order is undefined, so we order args alphabetically
        args = list(self.arguments[pos])
        args.sort()

        return "COMPREPLY=( $( compgen -W \"" + ' '.join(args) + "\" -- \"$cur\" ) )"


# commands where the option type can only be difficultly derived from the help message
SPECIAL_OPTIONS = [
        PossibleArgs("addnode").set_args(2, {"add", "remove", "onetry"}),
        PossibleArgs("setban").set_args(2, {"add", "remove"}),
]


def generate_start_complete(cword):
    """ Generate the start of an autocomplete block (beware of indentation). """
    if cword > 1:
        return """    if ((cword > {0})); then
        case ${{words[cword-{0}]}} in""".format(cword)

    return "    case \"$prev\" in"


def generate_end_complete(cword):
    """ Generate the end of an autocomplete block. """
    if cword > 1:
        return "\n{}esac\n{}fi\n\n".format(' '*8, ' '*4)

    return "\n{}esac\n".format(' '*4)


class CliCompletionTest(BitcoinTestFramework):
    def set_test_params(self):
        self.num_nodes = 1

    def skip_test_if_missing_module(self):
        self.skip_if_no_cli()
        self.skip_if_no_wallet()
        self.skip_if_no_bitcoind_zmq()  # zmq doesn't add commands to complete for now, but it might

    def add_options(self, parser):
        parser.add_argument(
            '--header',
            help='Static header part of the bitcoin-cli bash completion file',
        )

        parser.add_argument(
            '--footer',
            help='Static footer part of the bitcoin-cli bash completion file',
        )

        parser.add_argument(
            '--completion',
            help='Location of the current bash completion file',
        )

        parser.add_argument(
            '--overwrite',
            default=False,
            action='store_true',
            help='Force the test to pass by overwriting the file pointed by --completion '
                 'to a newly generated autocompletion file',
        )

    def parse_single_helper(self, option):
        """ Complete the arguments of option via the RPC help command. """

        # if we can't find an argument list in the help text, then it has no option to add
        regexp_res = ARG_REGEXP.match(self.nodes[0].help(option.command))
        if regexp_res is None or regexp_res.group(1) is None:
            return option

        # add options while looping over each first line of each argument
        arg_idx = 0
        for argument_line in [argl for argl in regexp_res.group(1).split('\n') if len(argl) > 0]:
            new_argument_start = str(arg_idx+1)+". "
            if argument_line.startswith(new_argument_start):
                arg_idx += 1
                argument = argument_line[len(new_argument_start):]

                # check if it's a special type option
                for option_type in TYPED_OPTIONS:
                    if argument.startswith(option_type[0]):
                        option.set_args(arg_idx, option_type[1])
                        continue

                # heuristic to try to guess when an argument is boolean
                if " (boolean," in argument_line:
                    option.set_bool_args(arg_idx)
                    continue

                # heuristic to try to guess when an argument is a file
                if " (string," in argument_line and "file" in argument_line:
                    option.set_file_args(arg_idx)
                    continue

                if not option.has_option(arg_idx):
                    option.set_unknwon_args(arg_idx)

        return option

    def get_command_options(self, command):
        """ Returns the corresponding PossibleArgs for the command. """

        # verify it's not a special option first
        for soption in SPECIAL_OPTIONS:
            if command == soption.command:
                return self.parse_single_helper(soption)

        return self.parse_single_helper(PossibleArgs(command))

    def generate_completion_block(self, options):
        commands = [o.command for o in options]
        self.log.info("Generating part of the completion file for options {}".format(commands))

        if len(options) == 0:
            return ""

        generated = ""
        max_pos_options = max(options, key=lambda o: o.get_num_args()).get_num_args()
        for cword in range(max_pos_options, 0, -1):
            this_options = [option for option in options if option.has_option(cword)]
            if len(this_options) == 0:
                continue

            # group options by their arguments value
            grouped_options = defaultdict(list)
            for option in this_options:
                arg = option.generate_autocomplete(cword)
                grouped_options[arg].append(option)

            # generate the cword block
            indent = 12 if cword > 1 else 8
            generated += generate_start_complete(cword)
            for line, opt_gr in grouped_options.items():
                opt_gr.sort(key=lambda o: o.command)  # show options alphabetically for clarity
                args = '|'.join([o.command for o in opt_gr])
                generated += "\n{}{})\n".format(' '*indent, args)
                generated += "{0}{1}\n{0}return 0\n{0};;".format(' '*(indent+4), line)
            generated += generate_end_complete(cword)

        return generated

    def generate_completion_file(self, commands):
        try:
            with open(self.options.header, 'r', encoding='utf-8') as header_file:
                header = header_file.read()

            with open(self.options.footer, 'r', encoding='utf-8') as footer_file:
                footer = footer_file.read()
        except Exception as e:
            raise AssertionError(("Could not read header/footer ({} and {}) files. Tell the test "
                                 "where to find them using the --header/--footer parameters ({}).")
                                 .format(self.options.header, self.options.footer, e))

        return COMPLETION_HEADER + header + commands + footer

    def write_completion_file(self, new_file):
        try:
            with open(self.options.completion, 'w', encoding='utf-8') as completion_file:
                completion_file.write(new_file)
        except Exception as e:
            raise AssertionError(("Could not write the autocomplete file to {}. Tell the test "
                                 "where to find it using the --completion parameters ({}).")
                                 .format(self.options.completion, e))

    def read_completion_file(self):
        try:
            with open(self.options.completion, 'r', encoding='utf-8') as completion_file:
                return completion_file.read()
        except Exception as e:
            raise AssertionError(("Could not read the autocomplete file ({}) file. Tell the test "
                                 "where to find it using the --completion parameters ({}).")
                                 .format(self.options.completion, e))

    def run_test(self):
        # self.config is not available in self.add_options, so complete filepaths here
        print("ENVIRONMENT: ", self.config["environment"])
        with open(self.options.configfile, 'r', encoding='utf-8') as conf:
            print(conf.read())

        srcdir = self.config["environment"]["SRCDIR"]
        test_data_dir = path.join(srcdir, 'test', 'functional', 'data', 'completion')
        if self.options.header is None or len(self.options.header) == 0:
            self.options.header = path.join(test_data_dir, 'bitcoin-cli.header.bash-completion')
        if self.options.footer is None or len(self.options.footer) == 0:
            self.options.footer = path.join(test_data_dir, 'bitcoin-cli.footer.bash-completion')
        if self.options.completion is None or len(self.options.completion) == 0:
            self.options.completion = path.join(srcdir, 'contrib', 'bitcoin-cli.bash-completion')

        self.log.info("Parsing help commands to get all commands arguments...")
        commands = self.nodes[0].help().split("\n")
        commands = [c.split(' ')[0] for c in commands if not c.startswith("== ") and len(c) > 0]
        commands = [self.get_command_options(c) for c in commands]

        self.log.info("Generating new autocompletion file...")
        commands = self.generate_completion_block(commands)
        new_completion = self.generate_completion_file(commands)

        if self.options.overwrite:
            self.log.info("Overwriting autocompletion file...")
            self.write_completion_file(new_completion)

        self.log.info("Checking that generated and original completion files matches...")
        completion = self.read_completion_file()
        assert_equal(new_completion, completion)


if __name__ == '__main__':
    CliCompletionTest().main()
